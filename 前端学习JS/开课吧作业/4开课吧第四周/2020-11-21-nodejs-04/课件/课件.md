# Nodejs-04

[toc]

## 上传

其实，本质上，每一次请求都是上传，服务器接收到请求响应给客户端就是下载。下载完成以后会根据具体的接受者（软件，如浏览器，迅雷……）来决定如何处理下载的内容。

前面我们了解了上传一般数据（字符）的过程，那么还有一些数据是图片，音频等，那这个时候上传数据又有一些特殊的规则。



### 上传的类型

请求也是发送的数据，所以请求的时候，也有一个请求头：content-type，这个请求的作用是告诉后端服务器，我现在提交的数据格式（MIME）类型是什么，然后后端服务器可以根据这个头信息来做对应的处理。

实际上 content-type 可以是任意格式的MIME类型，只要双方都实现处理就可以。

但是表单的 enctype 中只能设置如下三个：

```
1、application/x-www-form-urlencoded
	urlencoded：key=value&key=value...，这是表单默认的
2、multipart/form-data
	二进制格式：form-data，一般用来提交二进制数据（普通文本数据也可以通过这种格式来组织）
3、text/plain
	存文本格式
```

### koa-body

这个中间件默认只处理 application/x-www-form-urlencoded或者application/json，text/plain

> 注：如果提交的是multipart/form-data，普通的字符数据还是会被解析，然后通过 ctx.request.body 来进行访问，但是针对file类型的数据，会解析后存到 ctx.request.files 来进行访问

```
KoaBody({
	// 开启 multipart/form-data 的支持
	multipart: true,
	// 处理上传文件的后续逻辑，比如上传后的文件存储位置
	formidable: {
		// 上传后的文件存储的目录
		uploadDir: 
		// 是否保持原有的文件后缀扩展名
		keepExtensions: true,
	}
})
```

## 鉴权

问题：http协议是一个无状态协议，无状态：客户端和服务端链接以后，无法自动存储各自的状态（即使同一个客户端，多次请求，服务器是无法进行关联的）

我们需要提供一个验证的接口（/login），通过这个接口验证成功以后，返给前端一个标识（给它发一张vip卡），让这个人（客户端）以后每次请求把这张卡给同时携带过来（客户端一定要保存好这张卡）



服务端可以通过正文、响应头信息把这张卡的数据发送给客户端。客户端存储起来，以后每次请求携带过来。但是如果通过程序一点一点实现听麻烦的。客户端存储以后，浏览器的请求有时候我们不能去做任何处理，比如点击a发送请求的时候。



所以浏览器为了解决这个问题（存vip卡，每次请求发送vip卡信息），http定义了一个头信息：cookie

服务端通过发送一个头信息：set-cookie，把数据（vip）发送给客户端

当客户端（浏览器）接收的数据头信息中有 set-cookie这个字段，那么就主动存储起来。

当浏览器后续每次发送请求的时候，会首先去存储cookie的位置看一下有没有与当前这次请求的域有关的cookie（cookie是不会串，不同的域有自己cookie存储的空间），如果有，则把cookie数据通过请求头：cookies 发送给服务端。

服务端就可以每次在接收到请求的时候，看下请求头中是否存在cookie，如果有，验证合法性。……



## jwt

### jsonwebtoeken 库

## Koa-jwt 中间件